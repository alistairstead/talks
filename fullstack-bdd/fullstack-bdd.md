footer: \#BDD
slidenumbers: false

# [fit] Fullstack BDD
### and its side effects

---

* I'm not saying that is you are not doing BDD that you are doing it wrong
* I'm not saying that if you are not doing TDD that you are doing it wrong
* If it is a quick experiment then *hack* away
* Select the tools that help you get the results needed
* Is it a purely technical component, the unit tests may be enough?
* That said all code has an API, it exposes methods

* BDD is about dealing with the cost if translation, ubiqutous language allowing greater conversation
* Complexity has a translation cost. Complexity makes sense now, that seemingly elegant solution you spent the last 3 hours byte shifting. In 3 months will make little to know sense you you let alone others.
* Clean code protects us from creating complexity or at least it can with 4 simple rules.
* This reduces the cost of translating code you set down for a period of time.
* BDD examples show you how it works and more importantly why it is there. What value does it bring.

## Common errors

* Brittle scenarios tied to a specific UI
* Testing what you don't own
* Hard to test coupled code
* London school of TDD.... how does this manifest in the JavaScript testing tools?

## ES6 features to be wary of

* Type hinting to allow inversion of dependencies


* Cost of change
* Sustainable agility
* Pay down the technical debt
* refactoring - Changing the design of the software without changing it's behavior
* Automation
* The best TDD
  * Working from the outside in, test first
  * examples to clarify a requirement
  * Develop and use a ubiquitous language
* The best BDD
  * Focus on value
  * Discover examples collaboratively
  * Create living documentation

* Good - Principles > Practices > Tools
* Bad - Tools > Practices > Principles
